<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Prosopography Network - AGKI Epigraphy Tool</title>
  <link rel="stylesheet" href="assets/css/main.css">
  <script src="assets/js/basket.js"></script>

  <!-- D3.js for network visualization -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    main.page { max-width: none; width: 100%; padding: 2rem; }
    .dashboard-container { display: grid; grid-template-columns: minmax(280px, 340px) minmax(0, 1fr); gap: 1.75rem; margin-top: 2rem; align-items: start; width: 100%; }
    .sidebar { padding: 1.5rem; border-radius: 8px; position: sticky; top: 20px; max-height: calc(100vh - 40px); overflow-y: auto; }
    .filter-group { margin-bottom: 2rem; }
    .eyebrow { font-size: 0.8rem; text-transform: uppercase; color: var(--muted); margin-bottom: 0.5rem; font-weight: 700; }
    .search-box, .select-box, .range-input { width: 100%; padding: 0.6rem; border: 1px solid var(--border); background: var(--bg); color: var(--text); border-radius: 4px; }

    .viz-card { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem; box-shadow: var(--shadow); min-height: 700px; }
    .viz-title { margin: 0 0 1rem; font-size: 1rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.05em; border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }

    #networkContainer { width: 100%; height: 650px; position: relative; }
    #networkSvg { width: 100%; height: 100%; }

    .node { cursor: pointer; }
    .node circle { stroke: #fff; stroke-width: 2px; }
    .node text { font-size: 10px; fill: var(--text); pointer-events: none; }
    .node.highlighted circle { stroke: var(--primary); stroke-width: 3px; }
    .link { stroke: var(--border); stroke-opacity: 0.6; }
    .link.highlighted { stroke: var(--primary); stroke-opacity: 1; }

    .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; font-size: 0.85rem; }
    .legend-dot { width: 12px; height: 12px; border-radius: 50%; }

    .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }
    .stat-item { background: var(--bg); padding: 0.5rem; border-radius: 4px; text-align: center; }
    .stat-value { font-size: 1.5rem; font-weight: 700; color: var(--primary); }
    .stat-label { font-size: 0.75rem; color: var(--muted); }

    .node-info { background: var(--bg); padding: 1rem; border-radius: 4px; margin-top: 1rem; display: none; }
    .node-info.active { display: block; }
    .node-info h4 { margin: 0 0 0.5rem; color: var(--primary); }
    .node-info p { margin: 0.25rem 0; font-size: 0.85rem; }

    @media (max-width: 1200px) {
      .dashboard-container { grid-template-columns: 1fr; }
      .sidebar { position: static; }
    }
  </style>
  <script>
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.documentElement.setAttribute('data-theme', savedTheme);
  </script>
  <!-- Intro.js for Tours -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/intro.js@7.2.0/minified/introjs.min.css">
  <script src="https://cdn.jsdelivr.net/npm/intro.js@7.2.0/minified/intro.min.js"></script>
  <script src="assets/js/tour.js"></script>
</head>
<body>
  <header class="site-header">
    <div class="brand"><h1><a href="../index.html">AGKI Tagging Tool</a></h1></div>
    <nav class="nav-links">
        <a href="../index.html" class="nav-item">Home</a>
        <a href="search.html" class="nav-item">Search</a>
        <a href="explore.html" class="nav-item">Explore</a>
        <a href="basket.html" class="nav-item">Databasket</a>
        <a href="compare.html" class="nav-item">Compare</a>
        <a href="network.html" class="nav-item active">Network</a>
        <a href="matrix.html" class="nav-item">Matrix</a>
        <a href="indices.html" class="nav-item">Indices</a>
    </nav>
    <div class="header-controls">
        <button class="theme-toggle-btn" onclick="toggleTheme()" id="themeBtn">Dark Mode</button>
    </div>
  </header>

  <script>
    const themeBtn = document.getElementById('themeBtn');
    function updateThemeBtn() {
        const current = document.documentElement.getAttribute('data-theme');
        themeBtn.textContent = current === 'light' ? 'Dark Mode' : 'Light Mode';
    }
    updateThemeBtn();
    window.toggleTheme = function() {
        const current = document.documentElement.getAttribute('data-theme');
        const next = current === 'light' ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', next);
        localStorage.setItem('theme', next);
        updateThemeBtn();
    }
  </script>

  <main class="page page-wide">
    <div class="dashboard-container">
        <aside class="sidebar">
            <div class="filter-group">
                <h4 class="eyebrow">Network Controls</h4>
                <label style="font-size:0.85rem; display:block; margin-bottom:0.3rem;">Min. Co-occurrences</label>
                <input type="range" id="minEdgeWeight" min="1" max="10" value="1" style="width:100%; accent-color:var(--primary);">
                <div style="display:flex; justify-content:space-between; font-size:0.75rem; color:var(--muted);">
                    <span>1</span><span id="edgeWeightDisplay">1</span><span>10</span>
                </div>
            </div>

            <div class="filter-group">
                <h4 class="eyebrow">Region Filter</h4>
                <select id="regionFilter" class="select-box">
                    <option value="">All Regions</option>
                </select>
            </div>

            <div class="filter-group">
                <h4 class="eyebrow">Network Statistics</h4>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="nodeCount">0</div>
                        <div class="stat-label">Persons</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="edgeCount">0</div>
                        <div class="stat-label">Connections</div>
                    </div>
                </div>
            </div>

            <div class="filter-group">
                <h4 class="eyebrow">Legend</h4>
                <div class="legend-item"><span class="legend-dot" style="background: #c1683c;"></span> <span>High connections (5+)</span></div>
                <div class="legend-item"><span class="legend-dot" style="background: #0c8c88;"></span> <span>Medium (2-4)</span></div>
                <div class="legend-item"><span class="legend-dot" style="background: #888;"></span> <span>Low (1)</span></div>
            </div>

            <div class="filter-group">
                <h4 class="eyebrow">Selected Node</h4>
                <div id="nodeInfo" class="node-info">
                    <p class="muted">Click a node to see details.</p>
                </div>
            </div>

            <div class="meta-grid">
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                    <button onclick="resetZoom()" class="button secondary block compact">Reset View</button>
                    <button onclick="exportNetwork()" class="button block compact">Export SVG</button>
                </div>
            </div>
        </aside>

        <div class="viz-card">
            <h3 class="viz-title">Prosopography Network - Co-mentioned Persons</h3>
            <div id="networkContainer">
                <canvas id="networkCanvas"></canvas>
            </div>
        </div>
    </div>
  </main>

  <footer class="site-footer">
    <div class="footer-content">
      © 2026 Florian Wachter | Private Non-Profit Research Project | 
      <a href="https://github.com/paxetheninja/AGKI-PM-TaggingEpigraphy" target="_blank">GitHub</a>
    </div>
    <div class="footer-legal">
      Impressum: Privates Forschungsprojekt. Verantwortlich: Florian Wachter, Institut für Antike, Goethestraße 19, 8010 Graz. Kontakt: florian.wachter@uni-graz.at. Keine Gewähr für die Richtigkeit der Daten.
    </div>
  </footer>

  <script src="assets/js/data.js"></script>
  <script>
    let simulation, canvas, ctx, transform;
    let width, height;
    let networkData = { nodes: [], links: [] };
    let allNetworkData = { nodes: [], links: [] };
    let hoveredNode = null;
    let selectedNode = null;

    // Define colors
    const COLOR_HIGH = '#c1683c';
    const COLOR_MED = '#0c8c88';
    const COLOR_LOW = '#888';
    const COLOR_BG = getComputedStyle(document.documentElement).getPropertyValue('--panel').trim();
    const COLOR_TEXT = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();

    function init() {
        // Build region select
        const regions = new Set(APP_DATA.inscriptions.map(i => i.region).filter(Boolean));
        const regSelect = document.getElementById('regionFilter');
        Array.from(regions).sort().forEach(r => {
            const opt = document.createElement('option');
            opt.value = r;
            opt.textContent = r;
            regSelect.appendChild(opt);
        });

        // Set default weight to 2 to improve initial perf
        document.getElementById('minEdgeWeight').value = 2;
        document.getElementById('edgeWeightDisplay').textContent = "2";

        // Build network data
        buildNetworkData(APP_DATA.inscriptions);

        // Initialize Canvas
        initNetwork();

        // Event listeners
        document.getElementById('minEdgeWeight').addEventListener('input', (e) => {
            document.getElementById('edgeWeightDisplay').textContent = e.target.value;
            filterNetwork();
        });

        document.getElementById('regionFilter').addEventListener('change', () => {
            const region = document.getElementById('regionFilter').value;
            const filtered = region
                ? APP_DATA.inscriptions.filter(i => i.region === region)
                : APP_DATA.inscriptions;
            buildNetworkData(filtered);
            filterNetwork();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (canvas && document.getElementById('networkContainer')) {
                const container = document.getElementById('networkContainer');
                width = container.clientWidth;
                height = container.clientHeight;
                canvas.width = width;
                canvas.height = height;
                if (simulation) {
                    simulation.force('center', d3.forceCenter(width / 2, height / 2));
                    simulation.alpha(0.3).restart();
                }
                render();
            }
        });
    }

    function buildNetworkData(inscriptions) {
        const edges = new Map();
        const nodeSet = new Map();

        inscriptions.forEach(item => {
            const persons = item.mentioned_persons || [];
            const names = persons.map(p => p.name).filter(Boolean);

            // Add nodes
            names.forEach(name => {
                if (!nodeSet.has(name)) {
                    const person = persons.find(p => p.name === name);
                    nodeSet.set(name, {
                        id: name,
                        role: person?.role || '',
                        count: 0,
                        connections: 0,
                        inscriptions: []
                    });
                }
                nodeSet.get(name).count++;
                if (!nodeSet.get(name).inscriptions.includes(item.id)) {
                    nodeSet.get(name).inscriptions.push(item.id);
                }
            });

            // Add edges (co-occurrences)
            for (let i = 0; i < names.length; i++) {
                for (let j = i + 1; j < names.length; j++) {
                    const key = [names[i], names[j]].sort().join('|||');
                    if (!edges.has(key)) {
                        edges.set(key, {
                            source: names[i],
                            target: names[j],
                            weight: 0,
                            inscriptions: []
                        });
                    }
                    edges.get(key).weight++;
                    edges.get(key).inscriptions.push(item.id);
                }
            }
        });

        // Count connections per node (degree)
        edges.forEach(edge => {
            // Note: edge.source/target are just strings here
            if (nodeSet.has(edge.source)) nodeSet.get(edge.source).connections++;
            if (nodeSet.has(edge.target)) nodeSet.get(edge.target).connections++;
        });

        allNetworkData = {
            nodes: Array.from(nodeSet.values()),
            links: Array.from(edges.values())
        };
    }

    function filterNetwork() {
        const minWeight = parseInt(document.getElementById('minEdgeWeight').value);

        // Filter links by weight
        const filteredLinks = allNetworkData.links.filter(l => l.weight >= minWeight).map(l => ({...l})); // shallow copy

        // Get nodes that have at least one connection in the filtered set
        const connectedNodeIds = new Set();
        filteredLinks.forEach(l => {
            connectedNodeIds.add(l.source); // string id
            connectedNodeIds.add(l.target); // string id
        });

        const filteredNodes = allNetworkData.nodes
            .filter(n => connectedNodeIds.has(n.id))
            .map(n => ({...n})); // shallow copy to reset simulation state if needed

        networkData = { nodes: filteredNodes, links: filteredLinks };

        // Update stats
        document.getElementById('nodeCount').textContent = filteredNodes.length;
        document.getElementById('edgeCount').textContent = filteredLinks.length;

        updateSimulation();
    }

    function initNetwork() {
        const container = document.getElementById('networkContainer');
        width = container.clientWidth;
        height = container.clientHeight;

        canvas = document.getElementById('networkCanvas');
        canvas.width = width;
        canvas.height = height;
        ctx = canvas.getContext('2d');

        // Setup Zoom
        transform = d3.zoomIdentity;
        d3.select(canvas).call(d3.zoom()
            .scaleExtent([0.1, 8])
            .on('zoom', (event) => {
                transform = event.transform;
                render();
            }))
            .on('dblclick.zoom', null); // Disable double click zoom

        // Setup Drag
        d3.select(canvas).call(d3.drag()
            .subject(dragSubject)
            .on('start', dragStarted)
            .on('drag', dragged)
            .on('end', dragEnded));

        // Setup Mouse Interaction
        d3.select(canvas)
            .on('mousemove', mouseMoved)
            .on('click', mouseClicked);

        simulation = d3.forceSimulation()
            .force('charge', d3.forceManyBody().strength(-100))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(d => Math.min(5 + d.count * 2, 20) + 2))
            .force('link', d3.forceLink().id(d => d.id).distance(100));

        filterNetwork();
    }

    function updateSimulation() {
        simulation.nodes(networkData.nodes);
        simulation.force('link').links(networkData.links);
        simulation.alpha(1).restart();
        simulation.on('tick', render);
    }

    function render() {
        ctx.save();
        ctx.clearRect(0, 0, width, height);
        ctx.translate(transform.x, transform.y);
        ctx.scale(transform.k, transform.k);

        // Draw Links
        ctx.globalAlpha = 0.6;
        networkData.links.forEach(d => {
            const isHighlighted = hoveredNode && (d.source.id === hoveredNode.id || d.target.id === hoveredNode.id);
            const isSelected = selectedNode && (d.source.id === selectedNode.id || d.target.id === selectedNode.id);
            
            ctx.beginPath();
            ctx.moveTo(d.source.x, d.source.y);
            ctx.lineTo(d.target.x, d.target.y);
            
            if (isHighlighted || isSelected) {
                ctx.strokeStyle = COLOR_HIGH; // Highlight color
                ctx.lineWidth = Math.min(d.weight, 5) * 1.5;
                ctx.globalAlpha = 1;
            } else {
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = Math.min(d.weight, 5);
                ctx.globalAlpha = hoveredNode ? 0.1 : 0.6; // Fade others if hovering
            }
            ctx.stroke();
        });

        // Draw Nodes
        networkData.nodes.forEach(d => {
            const isHighlighted = hoveredNode && (d.id === hoveredNode.id || isConnected(d, hoveredNode));
            const isSelected = selectedNode && d.id === selectedNode.id;
            
            if (hoveredNode && !isHighlighted && !isSelected) {
                ctx.globalAlpha = 0.1; // Fade unrelated nodes
            } else {
                ctx.globalAlpha = 1;
            }

            ctx.beginPath();
            const r = Math.min(5 + d.count * 2, 20);
            ctx.arc(d.x, d.y, r, 0, 2 * Math.PI);
            
            // Fill Color based on connections
            if (d.connections >= 5) ctx.fillStyle = COLOR_HIGH;
            else if (d.connections >= 2) ctx.fillStyle = COLOR_MED;
            else ctx.fillStyle = COLOR_LOW;
            
            if (isSelected) {
                ctx.strokeStyle = COLOR_TEXT;
                ctx.lineWidth = 3;
                ctx.stroke();
            } else if (isHighlighted) {
                ctx.strokeStyle = COLOR_TEXT;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            ctx.fill();

            // Text Label (only draw if zoomed in or highlighted)
            if (transform.k > 1.2 || isHighlighted || isSelected || r > 10) {
                ctx.fillStyle = COLOR_TEXT;
                ctx.font = '10px sans-serif';
                ctx.fillText(d.id.length > 20 ? d.id.substring(0, 20) + '...' : d.id, d.x + r + 2, d.y + 3);
            }
        });

        ctx.restore();
    }

    // --- Interaction Helpers ---

    function isConnected(a, b) {
        if (!a || !b) return false;
        return networkData.links.some(l => 
            (l.source.id === a.id && l.target.id === b.id) || 
            (l.source.id === b.id && l.target.id === a.id)
        );
    }

    function getMousePos(event) {
        const rect = canvas.getBoundingClientRect();
        const x = transform.invertX(event.clientX - rect.left);
        const y = transform.invertY(event.clientY - rect.top);
        return [x, y];
    }

    function dragSubject(event) {
        const [x, y] = getMousePos(event);
        return simulation.find(x, y, 20);
    }

    function dragStarted(event) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
    }

    function dragged(event) {
        const [x, y] = getMousePos(event);
        event.subject.fx = x;
        event.subject.fy = y;
    }

    function dragEnded(event) {
        if (!event.active) simulation.alphaTarget(0);
        event.subject.fx = null;
        event.subject.fy = null;
    }

    function mouseMoved(event) {
        const [x, y] = getMousePos(event);
        const node = simulation.find(x, y, 20);
        
        if (node !== hoveredNode) {
            hoveredNode = node;
            canvas.style.cursor = node ? 'pointer' : 'move';
            render();
        }
    }

    function mouseClicked(event) {
        const [x, y] = getMousePos(event);
        const node = simulation.find(x, y, 20);
        
        if (node) {
            selectedNode = node;
            showNodeInfo(node);
            render();
        } else {
            selectedNode = null;
            document.getElementById('nodeInfo').classList.remove('active');
            render();
        }
    }

    function showNodeInfo(d) {
        const infoDiv = document.getElementById('nodeInfo');
        const connections = networkData.links.filter(l =>
            l.source.id === d.id || l.target.id === d.id
        );

        const connectedNames = connections.map(l => 
            l.source.id === d.id ? l.target.id : l.source.id
        ).slice(0, 5);

        infoDiv.innerHTML = `
            <h4>${d.id}</h4>
            <p><strong>Role:</strong> ${d.role || 'Unknown'}</p>
            <p><strong>Mentions:</strong> ${d.count}</p>
            <p><strong>Connections:</strong> ${d.connections}</p>
            <p><strong>Connected to:</strong> ${connectedNames.join(', ')}${connections.length > 5 ? '...' : ''}</p>
            <div style="display:flex; gap:0.5rem; margin-top:0.5rem;">
                <a href="search.html?q=${encodeURIComponent(d.id)}" class="button compact">View Inscriptions</a>
                <button onclick="window.basket.addMany([${d.inscriptions.join(',')}])" class="button secondary compact">Add to Basket</button>
            </div>
        `;
        infoDiv.classList.add('active');
    }

    function resetZoom() {
        d3.select(canvas).transition().duration(750).call(
            d3.zoom().transform,
            d3.zoomIdentity
        );
    }

    function exportNetwork() {
        const link = document.createElement('a');
        link.download = 'network.png';
        link.href = canvas.toDataURL();
        link.click();
    }

    // Initialize Tour
    document.addEventListener('DOMContentLoaded', () => {
        init();
        if (window.AGKI_Tour) AGKI_Tour.init('network');
    });
  </script>
</body>
</html>
