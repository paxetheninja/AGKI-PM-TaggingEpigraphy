<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Explore - AGKI Epigraphy Tool</title>
  <link rel="stylesheet" href="assets/css/main.css">
  
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <!-- Leaflet MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>

  <style>
    main.page { max-width: none; width: 100%; padding: 2rem; }
    .dashboard-container { display: grid; grid-template-columns: minmax(280px, 340px) minmax(0, 1fr); gap: 1.75rem; margin-top: 2rem; align-items: start; width: 100%; }
    .sidebar { padding: 1.5rem; border-radius: 8px; position: sticky; top: 20px; max-height: calc(100vh - 40px); overflow-y: auto; }
    .filter-group { margin-bottom: 2rem; }
    .eyebrow { font-size: 0.8rem; text-transform: uppercase; color: var(--muted); margin-bottom: 0.5rem; font-weight: 700; }
    .search-box, .select-box, .range-input { width: 100%; padding: 0.6rem; border: 1px solid var(--border); background: var(--bg); color: var(--text); border-radius: 4px; }
    
    .viz-layout { display: flex; flex-direction: column; gap: 2rem; min-width: 0; }
    .viz-grid { display: grid; grid-template-columns: minmax(0, 1fr) minmax(0, 1fr); gap: 1.5rem; align-items: stretch; }
    .viz-wide { grid-column: 1 / -1; }
    .viz-card { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem; box-shadow: var(--shadow); display: flex; flex-direction: column; min-height: 360px; }
    .viz-title { margin: 0 0 1rem; font-size: 1rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.05em; border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }

    #map { height: clamp(480px, 70vh, 780px); width: 100%; border-radius: 4px; z-index: 1; flex-grow: 1; }
    .chart-container { position: relative; height: clamp(320px, 34vh, 420px); width: 100%; }
    #sunburstChart { width: 100%; height: clamp(520px, 70vh, 820px); }

    /* Map Legend */
    .map-legend { background: var(--panel); padding: 10px; border-radius: 4px; border: 1px solid var(--border); font-size: 0.85rem; }
    .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
    .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; }
    .dot.combined { border: 3px solid #0c8c88; background: #c1683c; }

    /* Map Markers + Popups */
    .combined-marker-wrap { background: transparent; }
    .combined-marker {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 3px solid #0c8c88;
      background: #c1683c;
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.7);
    }
    .cluster-icon { background: transparent; }
    .cluster-badge {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 700;
      border: 2px solid #fff;
      box-shadow: var(--shadow);
    }
    .cluster-provenance { background: #c1683c; }
    .cluster-mentioned { background: #0c8c88; }
    .cluster-overlap { background: conic-gradient(#0c8c88 0 50%, #c1683c 50% 100%); }
    .popup-section { margin-top: 0.5rem; }
    .popup-title { font-weight: 700; margin-bottom: 0.25rem; }
    .popup-list { display: grid; gap: 0.25rem; max-height: 160px; overflow: auto; }
    .popup-row { display: flex; justify-content: space-between; gap: 0.5rem; }
    .popup-row a { color: var(--primary); text-decoration: none; }
    .popup-meta { color: var(--muted); font-size: 0.8rem; }
    .popup-caption { font-weight: 700; font-size: 1rem; margin-bottom: 0.65rem; }
    .popup-caption span { display: block; font-size: 0.8rem; font-weight: 600; color: var(--muted); margin-top: 0.15rem; }
    .popup-content { min-width: 220px; }
    .leaflet-popup-content-wrapper,
    .leaflet-popup-tip {
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    .leaflet-popup-content-wrapper { border-radius: 12px; }
    .leaflet-popup-content { margin: 14px; }
    .leaflet-bar a { background: var(--panel); color: var(--text); border-bottom: 1px solid var(--border); }
    .leaflet-bar a:hover { background: var(--bg); }

    /* Taxonomy Filter */
    .taxonomy-controls { display: grid; gap: 0.6rem; margin-bottom: 0.75rem; }
    .tax-row { display: flex; align-items: center; justify-content: space-between; gap: 0.5rem; flex-wrap: wrap; }
    .tax-mode-toggle { display: inline-flex; gap: 0.4rem; flex-wrap: wrap; }
    .tax-toggle { border: 1px solid var(--border); background: var(--bg); color: var(--text); padding: 0.3rem 0.65rem; border-radius: 999px; font-size: 0.75rem; cursor: pointer; }
    .tax-toggle.active { background: var(--primary); border-color: var(--primary); color: #fff; }
    .tax-clear { border: 1px solid var(--border); background: var(--panel); color: var(--text); padding: 0.3rem 0.6rem; border-radius: 6px; font-size: 0.75rem; cursor: pointer; }
    .tax-hint { font-size: 0.78rem; color: var(--muted); margin: 0; }
    .taxonomy-search { font-size: 0.85rem; }
    .taxonomy-actions { display: flex; gap: 0.4rem; flex-wrap: wrap; }
    .tax-action { border: 1px solid var(--border); background: var(--bg); color: var(--text); padding: 0.25rem 0.5rem; border-radius: 6px; font-size: 0.75rem; cursor: pointer; }
    .active-filters { display: flex; flex-wrap: wrap; gap: 0.4rem; }
    .active-filter-chip { display: inline-flex; align-items: center; gap: 0.3rem; border: 1px solid var(--border); background: var(--panel); color: var(--text); padding: 0.2rem 0.5rem; border-radius: 999px; font-size: 0.75rem; }
    .active-filter-chip.include { border-color: var(--primary); color: var(--primary); }
    .active-filter-chip.exclude { border-color: var(--error); color: var(--error); }
    .active-filter-chip button { border: none; background: transparent; color: inherit; cursor: pointer; font-size: 0.75rem; padding: 0; }
    .active-filter-empty { font-size: 0.78rem; color: var(--muted); }

    .tree-root { list-style: none; padding-left: 0; margin: 0; font-size: 0.9rem; }
    .tree-item { margin: 0.15rem 0; }
    .tree-item.hidden { display: none; }
    .tree-group { padding-left: 1.2rem; display: none; border-left: 1px solid var(--border); margin-left: 0.3rem; }
    .tree-group.open { display: block; }
    .tree-label-row { display: flex; align-items: center; gap: 0.4rem; padding: 2px 0; }
    .tree-label-row:hover { color: var(--primary); }
    .tree-caret { width: 16px; text-align: center; margin-right: 4px; color: var(--muted); font-size: 0.7em; transition: transform 0.2s; background: transparent; border: none; cursor: pointer; }
    .tree-caret.open { transform: rotate(90deg); }
    .tree-caret.empty { visibility: hidden; cursor: default; }
    .tree-label { flex: 1; font-size: 0.85rem; }
    .tax-count { font-size: 0.7rem; padding: 0.1rem 0.4rem; border-radius: 999px; border: 1px solid var(--border); color: var(--muted); }
    .tax-count.empty { opacity: 0.4; }
    .state-chip { border: 1px solid var(--border); background: var(--bg); color: var(--muted); padding: 0.15rem 0.5rem; border-radius: 999px; font-size: 0.7rem; cursor: pointer; }
    .state-chip.include { background: rgba(193, 104, 60, 0.15); border-color: var(--primary); color: var(--primary); }
    .state-chip.exclude { background: rgba(197, 34, 31, 0.15); border-color: var(--error); color: var(--error); }
    .filter-checkbox { margin-right: 8px; accent-color: var(--primary); }
    
    /* Collections & History */
    .collection-list, .history-list { list-style: none; padding: 0; margin: 0; }
    .collection-item, .history-item { font-size: 0.9rem; padding: 4px 0; border-bottom: 1px dashed var(--border); display: flex; justify-content: space-between; }
    .collection-item a, .history-item span { color: var(--primary); cursor: pointer; }
    .collection-remove { color: var(--muted); cursor: pointer; margin-left: 8px; }

    /* New Visualizations */
    .viz-row { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1.5rem; }
    .viz-small { min-height: 280px; }

    /* Donut Chart */
    #completenessChart { max-height: 220px; }
    .donut-legend { display: flex; flex-wrap: wrap; gap: 0.75rem; justify-content: center; margin-top: 0.75rem; font-size: 0.8rem; }
    .donut-legend-item { display: flex; align-items: center; gap: 0.4rem; }
    .donut-legend-color { width: 12px; height: 12px; border-radius: 3px; }

    /* Top Entities Panels */
    .entity-list { list-style: none; padding: 0; margin: 0; }
    .entity-item { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid var(--border); font-size: 0.85rem; }
    .entity-item:last-child { border-bottom: none; }
    .entity-name { color: var(--text); flex: 1; }
    .entity-name a { color: var(--primary); text-decoration: none; }
    .entity-name a:hover { text-decoration: underline; }
    .entity-count { background: var(--bg); color: var(--muted); padding: 0.15rem 0.5rem; border-radius: 999px; font-size: 0.75rem; font-weight: 600; }

    /* Heatmap */
    #heatmapChart { width: 100%; height: 400px; }

    /* Sankey */
    #sankeyChart { width: 100%; height: 450px; }

    @media (max-width: 1200px) {
      .dashboard-container { grid-template-columns: 1fr; }
      .sidebar { position: static; }
      .viz-grid { grid-template-columns: 1fr; }
      .viz-row { grid-template-columns: 1fr; }
    }

  </style>
  <script>
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.documentElement.setAttribute('data-theme', savedTheme);
  </script>
  <!-- Intro.js for Tours -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/intro.js@7.2.0/minified/introjs.min.css">
  <script src="https://cdn.jsdelivr.net/npm/intro.js@7.2.0/minified/intro.min.js"></script>
  <script src="assets/js/tour.js"></script>
</head>
<body>
  <header class="site-header">
    <div class="brand"><h1><a href="index.html">AGKI Tagging Tool</a></h1></div>
    <nav class="nav-links">
        <a href="index.html" class="nav-item">Home</a>
        <a href="search.html" class="nav-item">Search</a>
        <a href="explore.html" class="nav-item active">Explore</a>
        <a href="compare.html" class="nav-item">Compare</a>
        <a href="network.html" class="nav-item">Network</a>
        <a href="matrix.html" class="nav-item">Matrix</a>
        <a href="indices.html" class="nav-item">Indices</a>
    </nav>
    <div class="header-controls">
        <button class="theme-toggle-btn" onclick="toggleTheme()" id="themeBtn">Dark Mode</button>
    </div>
  </header>

  <script>
    const themeBtn = document.getElementById('themeBtn');
    function updateThemeBtn() {
        const current = document.documentElement.getAttribute('data-theme');
        themeBtn.textContent = current === 'light' ? 'Dark Mode' : 'Light Mode';
    }
    updateThemeBtn();
    window.toggleTheme = function() {
        const current = document.documentElement.getAttribute('data-theme');
        const next = current === 'light' ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', next);
        localStorage.setItem('theme', next);
        updateThemeBtn();
    }
  </script>

  <main class="page page-wide">
    <div class="dashboard-container">
        <aside class="sidebar">
            <div class="filter-group">
                <h4 class="eyebrow">Search Context</h4>
                <input type="text" id="searchInput" class="search-box" placeholder="Filter by keyword...">
            </div>
            <div class="filter-group">
                <h4 class="eyebrow">Taxonomy Filter</h4>
                <div class="taxonomy-controls">
                    <div class="tax-row">
                        <div class="tax-mode-toggle" role="group" aria-label="Taxonomy filter mode">
                            <button type="button" class="tax-toggle" data-value="any">Any (OR)</button>
                            <button type="button" class="tax-toggle" data-value="all">All (AND)</button>
                        </div>
                        <button type="button" class="tax-clear" id="clearTaxonomy">Clear All</button>
                    </div>
                    <p class="tax-hint">Click a tag to include. Click again to exclude. Click again to reset.</p>
                    <input type="text" id="taxonomySearch" class="search-box taxonomy-search" placeholder="Search taxonomy...">
                    <div class="taxonomy-actions">
                        <button type="button" class="tax-action" id="expandAllTaxonomy">Expand All</button>
                        <button type="button" class="tax-action" id="collapseAllTaxonomy">Collapse All</button>
                    </div>
                    <div id="activeFilters" class="active-filters"></div>
                </div>
                <div id="taxonomyTreeContainer"></div>
            </div>
            <div class="filter-group">
                <h4 class="eyebrow">Map Settings</h4>
                <div class="map-legend">
                    <div class="legend-item"><span class="dot" style="background: #c1683c;"></span> <span>Inscription Source</span></div>
                    <div class="legend-item"><span class="dot" style="background: #0c8c88;"></span> <span>Mentioned in Text</span></div>
                    <div class="legend-item"><span class="dot combined"></span> <span>Overlap</span></div>
                </div>
            </div>
            <div class="filter-group">
                <h4 class="eyebrow">My Collection</h4>
                <ul id="myCollectionList" class="collection-list">
                    <!-- Populated by JS -->
                    <li class="muted" style="font-size:0.85rem;">No starred items.</li>
                </ul>
            </div>
            <div class="filter-group">
                <h4 class="eyebrow">Search History</h4>
                <ul id="searchHistoryList" class="history-list">
                    <!-- Populated by JS -->
                </ul>
            </div>
            <div class="meta-grid">
                <div><p class="label">Analyzing</p><strong id="countDisplay">0</strong> Inscriptions</div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-top:0.5rem;">
                    <button onclick="exportData('json')" class="button block compact">JSON</button>
                    <button onclick="exportData('csv')" class="button secondary block compact">CSV</button>
                </div>
            </div>
        </aside>

        <div class="viz-layout">
            <div class="viz-card" style="min-height: 500px;">
                <h3 class="viz-title">Geospatial Relations</h3>
                <div id="map"></div>
            </div>
            <!-- Row: Completeness + Top Entities -->
            <div class="viz-row">
                <div class="viz-card viz-small">
                    <h3 class="viz-title">Completeness</h3>
                    <canvas id="completenessChart"></canvas>
                    <div id="completenessLegend" class="donut-legend"></div>
                </div>
                <div class="viz-card viz-small">
                    <h3 class="viz-title">Top Deities</h3>
                    <ul id="topDeities" class="entity-list"></ul>
                </div>
                <div class="viz-card viz-small">
                    <h3 class="viz-title">Top Places</h3>
                    <ul id="topPlaces" class="entity-list"></ul>
                </div>
            </div>

            <div class="viz-grid">
                <div class="viz-card viz-wide">
                    <h3 class="viz-title">Time Distribution</h3>
                    <div class="chart-container">
                        <canvas id="timeChart"></canvas>
                    </div>
                </div>
                <div class="viz-card viz-wide">
                    <h3 class="viz-title">Taxonomy Sunburst</h3>
                    <div id="sunburstChart"></div>
                </div>
            </div>

            <!-- Sankey: Region to Theme Flow -->
            <div class="viz-card viz-wide">
                <h3 class="viz-title">Region → Theme Flow (Sankey)</h3>
                <div id="sankeyChart"></div>
            </div>

            <!-- Heatmap: Themes × Regions -->
            <div class="viz-card viz-wide">
                <h3 class="viz-title">Theme × Region Heatmap</h3>
                <div id="heatmapChart"></div>
            </div>
        </div>
    </div>
  </main>

  <script>
    // --- Data Handling ---
    const script = document.createElement('script');
    script.src = `assets/js/data.js`;
    script.onload = () => init();
    document.body.appendChild(script);

    // --- Utilities ---
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    function normalizeText(value) {
        return value ? value.toString().toLowerCase() : '';
    }

    function loadTaxonomyState() {
        try {
            const stored = JSON.parse(localStorage.getItem(TAXONOMY_STATE_KEY) || '{}');
            if (stored.filters && typeof stored.filters === 'object') {
                activeFilters = new Map(Object.entries(stored.filters));
            }
            if (stored.mode === 'all' || stored.mode === 'any') {
                taxMode = stored.mode;
            }
            if (Array.isArray(stored.expanded)) {
                expandedPaths = new Set(stored.expanded);
            }
        } catch (e) {
            activeFilters = new Map();
            expandedPaths = new Set();
            taxMode = 'any';
        }
    }

    function saveTaxonomyState() {
        const filters = {};
        activeFilters.forEach((value, key) => { filters[key] = value; });
        localStorage.setItem(TAXONOMY_STATE_KEY, JSON.stringify({
            filters,
            mode: taxMode,
            expanded: Array.from(expandedPaths)
        }));
    }

    function setTaxMode(nextMode, options = {}) {
        taxMode = nextMode === 'all' ? 'all' : 'any';
        document.querySelectorAll('.tax-toggle').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.value === taxMode);
        });
        if (!options.skipSave) saveTaxonomyState();
        if (!options.skipFilter) filterData();
    }

    function updateFilterChip(path) {
        const node = taxonomyNodes.get(path);
        if (!node) return;
        const chip = node.chip;
        const state = activeFilters.get(path);
        chip.classList.remove('include', 'exclude');
        if (state === 'include') {
            chip.classList.add('include');
            chip.textContent = 'Include';
        } else if (state === 'exclude') {
            chip.classList.add('exclude');
            chip.textContent = 'Exclude';
        } else {
            chip.textContent = 'Off';
        }
    }

    function renderActiveFilters() {
        const container = document.getElementById('activeFilters');
        if (!container) return;
        container.innerHTML = '';
        if (activeFilters.size === 0) {
            const empty = document.createElement('span');
            empty.className = 'active-filter-empty';
            empty.textContent = 'No taxonomy filters applied.';
            container.appendChild(empty);
            return;
        }
        activeFilters.forEach((state, path) => {
            const chip = document.createElement('span');
            chip.className = `active-filter-chip ${state}`;
            chip.title = path;
            const label = document.createElement('span');
            label.textContent = `${state === 'include' ? 'Include' : 'Exclude'}: ${path.split('/').pop()}`;
            const remove = document.createElement('button');
            remove.type = 'button';
            remove.textContent = 'x';
            remove.onclick = () => {
                activeFilters.delete(path);
                updateFilterChip(path);
                renderActiveFilters();
                saveTaxonomyState();
                filterData();
            };
            chip.appendChild(label);
            chip.appendChild(remove);
            container.appendChild(chip);
        });
    }

    function setFilterState(path, state, options = {}) {
        if (state === 'off') {
            activeFilters.delete(path);
        } else {
            activeFilters.set(path, state);
        }
        updateFilterChip(path);
        renderActiveFilters();
        if (!options.skipSave) saveTaxonomyState();
        if (!options.skipFilter) filterData();
    }

    function cycleFilterState(path) {
        const current = activeFilters.get(path) || 'off';
        const next = current === 'include' ? 'exclude' : current === 'exclude' ? 'off' : 'include';
        setFilterState(path, next);
    }

    function setNodeExpanded(path, isOpen, options = {}) {
        const node = taxonomyNodes.get(path);
        if (!node || !node.group) return;
        node.group.classList.toggle('open', isOpen);
        node.caret.classList.toggle('open', isOpen);
        if (isOpen) {
            expandedPaths.add(path);
        } else {
            expandedPaths.delete(path);
        }
        if (!options.skipSave) saveTaxonomyState();
    }

    function expandPath(path) {
        const parts = path.split('/');
        let current = '';
        parts.forEach(part => {
            current = current ? `${current}/${part}` : part;
            setNodeExpanded(current, true, { skipSave: true });
        });
        saveTaxonomyState();
    }

    function expandAllTaxonomy() {
        taxonomyNodes.forEach((node, path) => {
            if (node.group) setNodeExpanded(path, true, { skipSave: true });
        });
        saveTaxonomyState();
    }

    function collapseAllTaxonomy() {
        taxonomyNodes.forEach((node, path) => {
            if (node.group) setNodeExpanded(path, false, { skipSave: true });
        });
        saveTaxonomyState();
    }

    function filterTaxonomyTree(term) {
        const searchTerm = normalizeText(term).trim();
        const hasTerm = searchTerm.length > 0;
        const root = document.querySelector('#taxonomyTreeContainer > ul');
        if (!root) return;

        function filterNode(li) {
            const path = li.dataset.path;
            const node = taxonomyNodes.get(path);
            const labelText = node ? normalizeText(node.label.textContent) : '';
            const selfMatch = hasTerm && labelText.includes(searchTerm);
            let childMatch = false;

            if (node && node.group) {
                Array.from(node.group.children).forEach(child => {
                    if (filterNode(child)) childMatch = true;
                });
            }

            const visible = !hasTerm || selfMatch || childMatch;
            li.classList.toggle('hidden', !visible);

            if (node && node.group) {
                if (hasTerm && visible) {
                    node.group.classList.add('open');
                    node.caret.classList.add('open');
                } else if (!hasTerm) {
                    const open = expandedPaths.has(path);
                    node.group.classList.toggle('open', open);
                    node.caret.classList.toggle('open', open);
                }
            }

            return selfMatch || childMatch;
        }

        Array.from(root.children).forEach(child => filterNode(child));
    }

    function updateTaxonomyCounts(data) {
        const counts = new Map();
        data.forEach(item => {
            const themes = Array.isArray(item.themes) ? item.themes : [];
            const seen = new Set();
            themes.forEach(t => {
                if (!t.path) return;
                const parts = t.path.split('/');
                let current = '';
                parts.forEach(part => {
                    current = current ? `${current}/${part}` : part;
                    seen.add(current);
                });
            });
            seen.forEach(path => {
                counts.set(path, (counts.get(path) || 0) + 1);
            });
        });

        taxonomyNodes.forEach((node, path) => {
            const count = counts.get(path) || 0;
            node.count.textContent = count.toString();
            node.count.classList.toggle('empty', count === 0);
        });
    }

    // --- State ---
    const TAXONOMY_STATE_KEY = 'agki_taxonomy_state_v1';
    let activeFilters = new Map(); // path -> 'include' | 'exclude'
    let taxMode = 'any';
    let expandedPaths = new Set();
    const taxonomyNodes = new Map();
    let chartInstances = {};
    let mapInstance = null;
    let mapClusterLayer = null;

    // --- Init ---
    function init() {
        loadTaxonomyState();
        buildTree(APP_DATA.taxonomy, '', document.getElementById('taxonomyTreeContainer'));
        setTaxMode(taxMode, { skipSave: true, skipFilter: true });
        activeFilters.forEach((state, path) => updateFilterChip(path));
        renderActiveFilters();

        // Taxonomy Controls
        document.querySelectorAll('.tax-toggle').forEach(btn => {
            btn.addEventListener('click', () => setTaxMode(btn.dataset.value));
        });
        document.getElementById('clearTaxonomy').addEventListener('click', () => {
            activeFilters.clear();
            taxonomyNodes.forEach((node, path) => updateFilterChip(path));
            renderActiveFilters();
            saveTaxonomyState();
            filterData();
        });
        document.getElementById('taxonomySearch').addEventListener('input', (e) => {
            filterTaxonomyTree(e.target.value);
        });
        document.getElementById('expandAllTaxonomy').addEventListener('click', expandAllTaxonomy);
        document.getElementById('collapseAllTaxonomy').addEventListener('click', collapseAllTaxonomy);

        const searchInput = document.getElementById('searchInput');
        searchInput.addEventListener('input', debounce((e) => {
            filterData();
            if(e.target.value.length > 3) addToHistory(e.target.value);
        }, 500));
        
        initCharts();
        initMap();
        renderCollection();
        renderHistory();
        filterTaxonomyTree('');
        filterData(); // Initial load
    }

    // --- Theme ---
    function updateThemeBtn() {
        const current = document.documentElement.getAttribute('data-theme');
        const btn = document.getElementById('themeBtn');
        if(btn) btn.textContent = current === 'light' ? 'Dark Mode' : 'Light Mode';
    }
    updateThemeBtn();

    window.toggleTheme = function() {
        const next = document.documentElement.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', next);
        localStorage.setItem('theme', next);
        updateThemeBtn();
        // Re-render Plotly charts with new theme colors
        if (window.lastFilteredData) {
            updateCharts(window.lastFilteredData);
        }
    }

    // --- Collections ---
    function getCollection() {
        return JSON.parse(localStorage.getItem('myCollection') || '[]');
    }

    function toggleCollection(id) {
        let col = getCollection();
        if (col.includes(id)) {
            col = col.filter(x => x !== id);
        } else {
            col.push(id);
        }
        localStorage.setItem('myCollection', JSON.stringify(col));
        renderCollection();
        updateMap(window.lastFilteredData || APP_DATA.inscriptions); // Refresh popups
    }

    function renderCollection() {
        const list = document.getElementById('myCollectionList');
        const col = getCollection();
        list.innerHTML = '';
        if (col.length === 0) {
            list.innerHTML = '<li class="muted" style="font-size:0.85rem;">No starred items.</li>';
            return;
        }
        col.forEach(id => {
            const item = APP_DATA.inscriptions.find(i => i.id == id);
            const label = item ? `PHI-${id} (${item.region})` : `PHI-${id}`;
            const li = document.createElement('li');
            li.className = 'collection-item';
            li.innerHTML = `<a href="inscriptions/${id}.html">${label}</a> <span class="collection-remove" onclick="toggleCollection(${id})">x</span>`;
            list.appendChild(li);
        });
    }

    // --- History ---
    function addToHistory(term) {
        let hist = JSON.parse(localStorage.getItem('searchHistory') || '[]');
        if (!hist.includes(term)) {
            hist.unshift(term);
            if(hist.length > 5) hist.pop();
            localStorage.setItem('searchHistory', JSON.stringify(hist));
            renderHistory();
        }
    }

    function renderHistory() {
        const list = document.getElementById('searchHistoryList');
        const hist = JSON.parse(localStorage.getItem('searchHistory') || '[]');
        list.innerHTML = '';
        if (hist.length === 0) {
            list.innerHTML = '<li class="muted" style="font-size:0.85rem;">No recent searches.</li>';
            return;
        }
        hist.forEach(term => {
            const li = document.createElement('li');
            li.className = 'history-item';
            li.innerHTML = `<span onclick="document.getElementById('searchInput').value='${term}'; filterData();">${term}</span>`;
            list.appendChild(li);
        });
    }

    // --- Filter Logic ---
    function filterData() {
        const searchTerm = normalizeText(document.getElementById('searchInput').value).trim();

        const inclusiveFilters = Array.from(activeFilters.entries()).filter(e => e[1] === 'include').map(e => e[0]);
        const exclusiveFilters = Array.from(activeFilters.entries()).filter(e => e[1] === 'exclude').map(e => e[0]);

        const baseFiltered = APP_DATA.inscriptions.filter(item => {
            const themeLabels = Array.isArray(item.themes_display) ? item.themes_display : [];
            const mentionedPlaces = Array.isArray(item.mentioned_places) ? item.mentioned_places : [];

            const matchesSearch = !searchTerm ||
                item.id.toString().includes(searchTerm) ||
                normalizeText(item.preview_text).includes(searchTerm) ||
                normalizeText(item.region).includes(searchTerm) ||
                normalizeText(item.date_str).includes(searchTerm) ||
                normalizeText(item.completeness).includes(searchTerm) ||
                themeLabels.some(label => normalizeText(label).includes(searchTerm)) ||
                mentionedPlaces.some(place => normalizeText(place.name).includes(searchTerm));

            return matchesSearch;
        });

        updateTaxonomyCounts(baseFiltered);

        const filtered = baseFiltered.filter(item => {
            const themes = Array.isArray(item.themes) ? item.themes : [];
            let passTaxonomy = true;

            if (exclusiveFilters.length > 0) {
                for (let t of themes) {
                    for (let f of exclusiveFilters) {
                        if (t.path.startsWith(f)) { passTaxonomy = false; break; }
                    }
                    if (!passTaxonomy) break;
                }
            }

            if (passTaxonomy && inclusiveFilters.length > 0) {
                if (taxMode === 'any') {
                    let matchFound = false;
                    for (let t of themes) {
                        for (let f of inclusiveFilters) {
                            if (t.path.startsWith(f)) { matchFound = true; break; }
                        }
                        if (matchFound) break;
                    }
                    passTaxonomy = matchFound;
                } else {
                    passTaxonomy = inclusiveFilters.every(f => {
                        return themes.some(t => t.path.startsWith(f));
                    });
                }
            }

            return passTaxonomy;
        });

        document.getElementById('countDisplay').textContent = filtered.length;
        window.lastFilteredData = filtered;
        
        // Update Visualizations
        updateCharts(filtered);
        updateMap(filtered);
    }

    // --- Map Logic ---
    function initMap() {
        mapInstance = L.map('map', { preferCanvas: true }).setView([38.0, 25.0], 6);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
            attribution: '? OSM',
            maxZoom: 18
        }).addTo(mapInstance);

        const clusterIcon = (cluster) => {
            const markers = cluster.getAllChildMarkers();
            let hasProv = false;
            let hasMen = false;
            markers.forEach((marker) => {
                const type = marker.options.markerType;
                if (type === 'overlap') { hasProv = true; hasMen = true; return; }
                if (type === 'provenance') { hasProv = true; }
                if (type === 'mentioned') { hasMen = true; }
            });
            const type = hasProv && hasMen ? 'overlap' : (hasProv ? 'provenance' : 'mentioned');
            const count = cluster.getChildCount();
            return L.divIcon({
                html: `<div class="cluster-badge cluster-${type}">${count}</div>`,
                className: 'cluster-icon',
                iconSize: L.point(36, 36)
            });
        };

        mapClusterLayer = L.markerClusterGroup({
            showCoverageOnHover: false,
            spiderfyOnMaxZoom: true,
            maxClusterRadius: 60,
            chunkedLoading: true,
            iconCreateFunction: clusterIcon
        });
        
        mapInstance.addLayer(mapClusterLayer);
    }

    function normalizeCoords(coords) {
        return [Number(coords[0]), Number(coords[1])];
    }

    function coordKey(coords) {
        return `${coords[0].toFixed(4)},${coords[1].toFixed(4)}`;
    }

    function buildCoordinateIndex(data) {
        const index = new Map();
        data.forEach(item => {
            if (item.coordinates) {
                const coords = normalizeCoords(item.coordinates);
                const key = coordKey(coords);
                if (!index.has(key)) {
                    index.set(key, { lat: coords[0], lng: coords[1], provenance: new Map(), mentioned: new Map() });
                }
                index.get(key).provenance.set(item.id, item);
            }

            if (item.mentioned_places && item.mentioned_places.length > 0) {
                item.mentioned_places.forEach(p => {
                    if (!p.coords) return;
                    const coords = normalizeCoords(p.coords);
                    const key = coordKey(coords);
                    if (!index.has(key)) {
                        index.set(key, { lat: coords[0], lng: coords[1], provenance: new Map(), mentioned: new Map() });
                    }
                    const entry = index.get(key);
                    if (!entry.mentioned.has(item.id)) {
                        entry.mentioned.set(item.id, []);
                    }
                    entry.mentioned.get(item.id).push(p);
                });
            }
        });
        return index;
    }

    function buildIdList(ids, collection) {
        const rows = ids.map(id => {
            const isStarred = collection.includes(id);
            const button = `<button class="button secondary tiny" onclick="toggleCollection(${id})">${isStarred ? 'Unstar' : 'Star'}</button>`;
            return `<div class="popup-row"><a href="inscriptions/${id}.html">PHI-${id}</a>${button}</div>`;
        });
        return rows.join('');
    }

    function buildMentionList(mentionedMap) {
        const rows = [];
        mentionedMap.forEach((mentions, id) => {
            const names = mentions.map(m => m.name).filter(Boolean).join(', ');
            const meta = names ? `<span class="popup-meta">${names}</span>` : '';
            rows.push(`<div class="popup-row"><a href="inscriptions/${id}.html">PHI-${id}</a>${meta}</div>`);
        });
        return rows.join('');
    }

    function resolveLocationLabel(entry) {
        const regions = new Set();
        entry.provenance.forEach(item => {
            if (item.region) regions.add(item.region);
        });
        const mentions = new Set();
        entry.mentioned.forEach((places) => {
            places.forEach((p) => {
                if (p.name) mentions.add(p.name);
            });
        });

        if (regions.size === 1) return { label: Array.from(regions)[0], source: 'Region' };
        if (mentions.size === 1) return { label: Array.from(mentions)[0], source: 'Place' };
        if (regions.size > 1) return { label: `Multiple regions (${regions.size})`, source: 'Region' };
        if (mentions.size > 1) return { label: `Multiple places (${mentions.size})`, source: 'Place' };
        return { label: 'Location', source: 'Area' };
    }

    function buildSection(title, content) {
        return `<div class="popup-section"><div class="popup-title">${title}</div><div class="popup-list">${content}</div></div>`;
    }

    function buildPopup(entry, collection) {
        const sections = [];
        const location = resolveLocationLabel(entry);
        const caption = `<div class="popup-caption">${location.label}<span>${location.source}</span></div>`;
        const provIds = Array.from(entry.provenance.keys()).sort((a, b) => a - b);
        const menIds = Array.from(entry.mentioned.keys()).sort((a, b) => a - b);

        if (provIds.length > 0) {
            sections.push(buildSection(`Provenance (${provIds.length})`, buildIdList(provIds, collection)));
        }
        if (menIds.length > 0) {
            sections.push(buildSection(`Mentioned (${menIds.length})`, buildMentionList(entry.mentioned)));
        }

        return `<div class="popup-content">${caption}${sections.join('')}</div>`;
    }

    function updateMap(data) {
        if (!mapClusterLayer) return;
        mapClusterLayer.clearLayers();

        const index = buildCoordinateIndex(data);
        const collection = getCollection();
        const combinedIcon = L.divIcon({
            className: 'combined-marker-wrap',
            html: '<div class="combined-marker"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });

        index.forEach(entry => {
            const coords = [entry.lat, entry.lng];
            const hasProv = entry.provenance.size > 0;
            const hasMen = entry.mentioned.size > 0;
            const popup = buildPopup(entry, collection);

            if (hasProv && hasMen) {
                mapClusterLayer.addLayer(L.marker(coords, { icon: combinedIcon, markerType: 'overlap' }).bindPopup(popup));
                return;
            }

            if (hasProv) {
                const marker = L.circleMarker(coords, {
                    radius: 6,
                    fillColor: "#c1683c",
                    color: "#fff",
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.85,
                    markerType: 'provenance'
                }).bindPopup(popup);
                mapClusterLayer.addLayer(marker);
            }

            if (hasMen) {
                const marker = L.circleMarker(coords, {
                    radius: 5,
                    fillColor: "#0c8c88",
                    color: "#fff",
                    weight: 1,
                    opacity: 0.9,
                    fillOpacity: 0.7,
                    markerType: 'mentioned'
                }).bindPopup(popup);
                mapClusterLayer.addLayer(marker);
            }
        });
        mapClusterLayer.refreshClusters();
    }

    // --- Charts ---

    function initCharts() {
        const commonOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' }
            }
        };

        chartInstances.time = new Chart(document.getElementById('timeChart').getContext('2d'), {
            type: 'bar',
            data: { labels: [], datasets: [{ label: 'Count', data: [], backgroundColor: '#c1683c' }] },
            options: commonOptions
        });

        // Completeness Donut Chart
        chartInstances.completeness = new Chart(document.getElementById('completenessChart').getContext('2d'), {
            type: 'doughnut',
            data: {
                labels: ['Intact', 'Fragmentary', 'Mutilated', 'Unknown'],
                datasets: [{
                    data: [0, 0, 0, 0],
                    backgroundColor: ['#2f8f5d', '#c1683c', '#c5221f', '#666666'],
                    borderWidth: 2,
                    borderColor: 'var(--panel)'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                cutout: '60%',
                plugins: {
                    legend: { display: false }
                }
            }
        });
    }

    function updateCharts(data) {
        // 1. Time Histogram (50 year bins)
        const timeBins = {};
        data.forEach(item => {
            if (item.date_min !== null && item.date_min !== undefined) {
                // Round to nearest 50
                const binSize = 50;
                const c = Math.floor(item.date_min / binSize) * binSize;
                const label = c < 0 ? `${Math.abs(c)} BC` : `${c} AD`;
                timeBins[c] = (timeBins[c] || 0) + 1;
            }
        });

        const sortedYears = Object.keys(timeBins).map(Number).sort((a,b) => a - b);
        const labels = sortedYears.map(y => y < 0 ? `${Math.abs(y)} BC` : `${y} AD`);
        const counts = sortedYears.map(y => timeBins[y]);

        chartInstances.time.data.labels = labels;
        chartInstances.time.data.datasets[0].data = counts;
        chartInstances.time.update();

        // 2. Completeness Donut
        updateCompletenessChart(data);

        // 3. Top Entities
        updateTopEntities(data);

        // 4. Heatmap
        updateHeatmap(data);

        // 5. Sankey
        updateSankey(data);

        // 6. Sunburst Chart
        const hierarchyMap = new Map();
        
        function addToHier(path) {
            let parentId = "";
            let currentId = "";
            const pathParts = path.split('/');
            
            pathParts.forEach((segment, idx) => {
                if(!segment) return;
                currentId = idx === 0 ? segment : `${parentId} - ${segment}`;
                if (!hierarchyMap.has(currentId)) {
                    hierarchyMap.set(currentId, {
                        id: currentId,
                        label: segment,
                        parent: idx === 0 ? "" : parentId,
                        value: 0
                    });
                }
                hierarchyMap.get(currentId).value++;
                parentId = currentId;
            });
        }

        data.forEach(item => {
            item.themes.forEach(t => {
                addToHier(t.path);
            });
        });

        const sunburstData = Array.from(hierarchyMap.values());

        const dark = isDarkMode();
        const fontColor = getPlotlyFontColor();

        const plotData = [{
            type: "sunburst",
            ids: sunburstData.map(d => d.id),
            labels: sunburstData.map(d => d.label),
            parents: sunburstData.map(d => d.parent),
            values: sunburstData.map(d => d.value),
            outsidetextfont: {size: 14, color: fontColor},
            insidetextfont: {color: dark ? '#fff' : '#333'},
            leaf: {opacity: dark ? 0.7 : 0.4},
            marker: {line: {width: 2, color: dark ? '#333' : '#fff'}},
            textfont: {color: fontColor}
        }];

        const layout = {
            margin: {l: 0, r: 0, b: 0, t: 0},
            sunburstcolorway: dark
                ? ["#e8a070", "#4ec9c5", "#f0a060", "#5cbfb0"]
                : ["#c1683c", "#0c8c88", "#d97b3d", "#2f8f5d"],
            paper_bgcolor: 'rgba(0,0,0,0)',
        };

        Plotly.newPlot('sunburstChart', plotData, layout, {displayModeBar: false});
    }

    // --- Completeness Donut ---
    function updateCompletenessChart(data) {
        const completenessCount = { intact: 0, fragmentary: 0, mutilated: 0, unknown: 0 };
        data.forEach(item => {
            const c = (item.completeness || '').toLowerCase();
            if (c === 'intact') completenessCount.intact++;
            else if (c === 'fragmentary') completenessCount.fragmentary++;
            else if (c === 'mutilated') completenessCount.mutilated++;
            else completenessCount.unknown++;
        });

        const values = [completenessCount.intact, completenessCount.fragmentary, completenessCount.mutilated, completenessCount.unknown];
        chartInstances.completeness.data.datasets[0].data = values;
        chartInstances.completeness.update();

        // Update legend
        const legendContainer = document.getElementById('completenessLegend');
        const colors = ['#2f8f5d', '#c1683c', '#c5221f', '#666666'];
        const labels = ['Intact', 'Fragmentary', 'Mutilated', 'Unknown'];
        legendContainer.innerHTML = labels.map((label, i) => `
            <div class="donut-legend-item">
                <span class="donut-legend-color" style="background:${colors[i]}"></span>
                <span>${label}: ${values[i]}</span>
            </div>
        `).join('');
    }

    // --- Top Entities ---
    function updateTopEntities(data) {
        // Deities
        const deityCounts = {};
        data.forEach(item => {
            (item.mentioned_deities || []).forEach(d => {
                deityCounts[d] = (deityCounts[d] || 0) + 1;
            });
        });
        const topDeities = Object.entries(deityCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 8);

        document.getElementById('topDeities').innerHTML = topDeities.length > 0
            ? topDeities.map(([name, count]) => `
                <li class="entity-item">
                    <span class="entity-name"><a href="search.html?q=${encodeURIComponent(name)}">${name}</a></span>
                    <span class="entity-count">${count}</span>
                </li>
            `).join('')
            : '<li class="entity-item"><span class="entity-name" style="color:var(--muted)">No deities found</span></li>';

        // Places
        const placeCounts = {};
        data.forEach(item => {
            (item.mentioned_places || []).forEach(p => {
                placeCounts[p.name] = (placeCounts[p.name] || 0) + 1;
            });
        });
        const topPlaces = Object.entries(placeCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 8);

        document.getElementById('topPlaces').innerHTML = topPlaces.length > 0
            ? topPlaces.map(([name, count]) => `
                <li class="entity-item">
                    <span class="entity-name"><a href="search.html?q=${encodeURIComponent(name)}">${name}</a></span>
                    <span class="entity-count">${count}</span>
                </li>
            `).join('')
            : '<li class="entity-item"><span class="entity-name" style="color:var(--muted)">No places found</span></li>';
    }

    // --- Theme detection helper ---
    function isDarkMode() {
        return document.documentElement.getAttribute('data-theme') === 'dark';
    }

    function getPlotlyFontColor() {
        return isDarkMode() ? '#e0e0e0' : '#333333';
    }

    // --- Heatmap: Theme × Region ---
    function updateHeatmap(data) {
        // Collect themes (first level only) and regions
        const themeSet = new Set();
        const regionSet = new Set();
        const matrix = {};

        data.forEach(item => {
            const region = item.region || 'Unknown';
            regionSet.add(region);
            (item.themes || []).forEach(t => {
                const topLevel = t.path.split('/')[0];
                themeSet.add(topLevel);
                const key = `${region}|${topLevel}`;
                matrix[key] = (matrix[key] || 0) + 1;
            });
        });

        const themes = Array.from(themeSet).sort();
        const regions = Array.from(regionSet).sort();

        if (themes.length === 0 || regions.length === 0) {
            Plotly.purge('heatmapChart');
            return;
        }

        // Build z-values (regions × themes)
        const z = regions.map(region =>
            themes.map(theme => matrix[`${region}|${theme}`] || 0)
        );

        // Dark mode aware colorscale
        const dark = isDarkMode();
        const colorscale = dark
            ? [[0, '#1e1e1e'], [0.3, '#4a3020'], [0.6, '#c1683c'], [1, '#ff9966']]
            : [[0, '#f5f5f5'], [0.3, '#f0d0b0'], [0.6, '#d97b3d'], [1, '#8b3a1d']];

        const fontColor = getPlotlyFontColor();

        const heatmapData = [{
            z: z,
            x: themes,
            y: regions,
            type: 'heatmap',
            colorscale: colorscale,
            hoverongaps: false,
            showscale: true,
            colorbar: {
                tickfont: { color: fontColor }
            }
        }];

        const layout = {
            margin: { l: 150, r: 30, t: 30, b: 100 },
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(0,0,0,0)',
            xaxis: {
                tickangle: -45,
                tickfont: { size: 10, color: fontColor },
                gridcolor: dark ? '#333' : '#ddd'
            },
            yaxis: {
                tickfont: { size: 10, color: fontColor },
                gridcolor: dark ? '#333' : '#ddd'
            }
        };

        Plotly.newPlot('heatmapChart', heatmapData, layout, { displayModeBar: false });
    }

    // --- Sankey: Region → Theme Flow ---
    function updateSankey(data) {
        // Build links: region -> theme (top-level)
        const linkCounts = {};
        const regionSet = new Set();
        const themeSet = new Set();

        data.forEach(item => {
            const region = item.region || 'Unknown';
            regionSet.add(region);
            (item.themes || []).forEach(t => {
                const topLevel = t.path.split('/')[0];
                themeSet.add(topLevel);
                const key = `${region}|||${topLevel}`;
                linkCounts[key] = (linkCounts[key] || 0) + 1;
            });
        });

        const regions = Array.from(regionSet).sort();
        const themes = Array.from(themeSet).sort();

        if (regions.length === 0 || themes.length === 0) {
            Plotly.purge('sankeyChart');
            return;
        }

        const dark = isDarkMode();
        const fontColor = getPlotlyFontColor();

        // Nodes: regions first, then themes
        const nodes = [...regions, ...themes];
        const nodeColors = [
            ...regions.map(() => dark ? '#e8a070' : '#c1683c'),
            ...themes.map(() => dark ? '#4ec9c5' : '#0c8c88')
        ];

        // Links
        const sources = [];
        const targets = [];
        const values = [];

        Object.entries(linkCounts).forEach(([key, count]) => {
            const [region, theme] = key.split('|||');
            const sourceIdx = regions.indexOf(region);
            const targetIdx = regions.length + themes.indexOf(theme);
            if (sourceIdx >= 0 && targetIdx >= regions.length) {
                sources.push(sourceIdx);
                targets.push(targetIdx);
                values.push(count);
            }
        });

        const sankeyData = [{
            type: 'sankey',
            orientation: 'h',
            node: {
                pad: 15,
                thickness: 20,
                line: { color: dark ? '#444' : '#ccc', width: 0.5 },
                label: nodes,
                color: nodeColors
            },
            link: {
                source: sources,
                target: targets,
                value: values,
                color: dark ? 'rgba(232, 160, 112, 0.4)' : 'rgba(193, 104, 60, 0.3)'
            }
        }];

        const layout = {
            margin: { l: 10, r: 10, t: 10, b: 10 },
            paper_bgcolor: 'rgba(0,0,0,0)',
            font: { size: 10, color: fontColor }
        };

        Plotly.newPlot('sankeyChart', sankeyData, layout, { displayModeBar: false });
    }

    function buildTree(node, path, container) {
        const ul = document.createElement('ul');
        ul.className = path ? 'tree-group' : 'tree-root';
        Object.keys(node).sort().forEach(key => {
            const cur = path ? `${path}/${key}` : key;
            const children = node[key];
            const has = children && Object.keys(children).length > 0;
            const li = document.createElement('li');
            li.className = 'tree-item';
            li.dataset.path = cur;
            const row = document.createElement('div');
            row.className = 'tree-label-row';
            
            const caret = document.createElement('button');
            caret.type = 'button';
            caret.className = `tree-caret ${has ? '' : 'empty'}`;
            caret.textContent = '>';
            if (!has) caret.disabled = true;

            const label = document.createElement('span');
            label.className = 'tree-label';
            label.textContent = key;

            const count = document.createElement('span');
            count.className = 'tax-count';
            count.textContent = '0';

            const chip = document.createElement('button');
            chip.type = 'button';
            chip.className = 'state-chip';
            chip.textContent = 'Off';

            const toggle = () => {
                if (!has) return;
                const isOpen = !caret.classList.contains('open');
                setNodeExpanded(cur, isOpen);
            };
            caret.onclick = (e) => { e.stopPropagation(); toggle(); };
            row.onclick = toggle;
            chip.onclick = (e) => { e.stopPropagation(); cycleFilterState(cur); };
            
            row.appendChild(caret);
            row.appendChild(label);
            row.appendChild(count);
            row.appendChild(chip);
            li.appendChild(row);

            let childGroup = null;
            if (has) {
                childGroup = buildTree(children, cur, li);
            }
            ul.appendChild(li);

            taxonomyNodes.set(cur, { li, caret, group: childGroup, label, count, chip });
            updateFilterChip(cur);
            if (childGroup && expandedPaths.has(cur)) {
                childGroup.classList.add('open');
                caret.classList.add('open');
            }
        });
        container.appendChild(ul);
        return ul;
    }
window.exportData = function(format) {
        const data = window.lastFilteredData || APP_DATA.inscriptions;
        let blob;
        let filename;

        if (format === 'csv') {
            const headers = ['ID', 'Region', 'Date', 'Completeness', 'Themes', 'Entities', 'Text Preview'];
            const rows = data.map(item => {
                const places = (item.mentioned_places || []).map(p => p.name).join('; ');
                const escape = (txt) => {
                    if (!txt) return "";
                    return '"' + txt.toString().replace(/"/g, '""') + '"';
                };
                return [
                    item.id,
                    escape(item.region),
                    escape(item.date_str),
                    escape(item.completeness),
                    escape(item.themes_display.join('; ')),
                    escape(places),
                    escape(item.preview_text)
                ].join(",");
            });
            const csvContent = [headers.join(","), ...rows].join("\n");
            blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            filename = "agki_export.csv";
        } else {
            const jsonContent = JSON.stringify(data, null, 2);
            blob = new Blob([jsonContent], { type: 'application/json' });
            filename = "agki_export.json";
        }
        
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    // Initialize tour
    document.addEventListener('DOMContentLoaded', () => {
        if (window.AGKI_Tour) AGKI_Tour.init('explore');
    });
  </script>
</body>
</html>




